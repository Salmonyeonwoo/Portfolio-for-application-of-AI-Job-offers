<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 코치 포트폴리오 - 기술적 도전과제 해결 스토리</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+KR:wght@100..900&display=swap');
        body { 
            font-family: 'Noto Sans KR', 'Inter', sans-serif;
            background-color: #f7f9fb; /* Light background for clean look */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 sm:p-8 max-w-4xl">

        <!-- Header (KOREAN) -->
        <header class="text-center mb-12 py-8 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-700">AI 학습 코치 포트폴리오</h1>
            <p class="mt-2 text-xl text-gray-500">기술적 도전과제: 지속성 계층(Persistence Layer) 구축 성공 스토리</p>
        </header>

        <!-- Header (ENGLISH) -->
        <header class="text-center mb-12 -mt-10 py-4 bg-indigo-50 rounded-xl shadow-inner border border-indigo-200">
            <h1 class="text-3xl font-bold text-indigo-600">AI Study Coach Portfolio</h1>
            <p class="mt-1 text-base text-indigo-500">Technical Challenge: Persistence Layer Implementation Success Story</p>
        </header>


        <!-- Section 1: Challenge Overview -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">1. 도전 과제 개요 (Challenge Overview)</h2>
            <div class="bg-white p-6 rounded-xl shadow-md">
                <p class="text-lg mb-4 text-gray-600">Streamlit Cloud 환경에서 RAG 인덱스(FAISS)를 영구적으로 저장하기 위해 Google Cloud Firestore(GCP)를 통합하는 과정에서, 예상치 못한 서버 인증 충돌과 환경 설정 문제에 직면했습니다.</p>
                <p class="text-base text-gray-500 italic">The core technical challenge was integrating Google Cloud Firestore for persistent storage of RAG indices (FAISS) within the Streamlit Cloud environment, leading to persistent server authentication and configuration issues.</p>
                
                <h3 class="text-2xl font-semibold text-gray-600 mt-6 mb-4">핵심 문제: Admin SDK 초기화 실패 (Core Problem: Admin SDK Init Failures)</h3>
                <div class="bg-red-50 p-4 rounded-lg border border-red-300">
                    <p class="text-red-700 font-medium">경험한 주요 오류 메시지: JSON 구문 오류, Datastore Mode 충돌, Invalid private key, AttrDict 타입 불일치 등 복합적 문제 발생.</p>
                    <p class="text-red-600 text-sm mt-1">Key Errors Experienced: JSON syntax errors, Datastore Mode conflict, Invalid private key, AttrDict type mismatch, indicating complex environmental and serialization issues.</p>
                </div>
            </div>
        </section>

        <!-- Section 2: Step-by-Step Resolution (Visualized) -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">2. 단계별 문제 해결 과정 (Step-by-Step Resolution)</h2>
            
            <div id="resolution-steps" class="space-y-8">
                
                <!-- Step 1: Mode Conflict & Project Change -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-fuchsia-500">
                    <h3 class="text-xl font-bold text-fuchsia-700 mb-3">단계 1: 데이터스토어 모드 충돌 및 프로젝트 변경 (Datastore Mode Conflict)</h3>
                    <p class="text-gray-600 mb-3">Firestore Native Mode를 사용해야 하는데 프로젝트가 Datastore Mode로 설정되어 발생하는 400 오류를 확인했습니다. 새로운 Firebase 프로젝트를 Native Mode로 생성하고 서비스 계정 키를 교체했습니다.</p>
                    <p class="text-gray-500 text-sm italic">Identified and resolved the 400 error caused by the project being set to Datastore Mode instead of Native Mode. Replaced the Service Account key with a new one from a Native Mode project.</p>
                </div>

                <!-- Step 2: JSON Parsing/Escape Fix (UPDATED WITH CODE) -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-yellow-500">
                    <h3 class="text-xl font-bold text-yellow-700 mb-3">단계 2: Secrets JSON 파싱 및 유효성 검사 (JSON Parsing & Validation)</h3>
                    <p class="text-gray-600 mb-3">Secrets 파일에 포함된 JSON 문자열의 구문 오류(유니코드 제어 문자, 이스케이프 문자) 및 Streamlit의 AttrDict 타입 문제를 해결하기 위해, 아래와 같이 로직을 구현하여 어떤 Secrets 형식(문자열, 딕셔너리)이 들어오더라도 표준 딕셔너리(dict)로 변환하도록 강제했습니다.</p>
                    <p class="text-gray-500 text-sm italic">Fixed JSON syntax errors and the Streamlit AttrDict type issue by implementing logic that explicitly forces the conversion of the secrets key into a standard Python dictionary (dict), ensuring compatibility with the Firebase Admin SDK.</p>
                    
                    <p class="mt-4 font-semibold text-gray-700">적용된 파이썬 코드 (_get_admin_credentials 함수)</p>
                    <div class="bg-gray-800 text-green-300 p-4 rounded-lg text-xs overflow-x-auto mt-2 shadow-inner">
<pre class="whitespace-pre-wrap">def _get_admin_credentials():
    # ... (생략: Secret 존재 여부 확인)
    
    service_account_data = st.secrets["FIREBASE_SERVICE_ACCOUNT_JSON"]
    sa_info = None

    if isinstance(service_account_data, str):
        # 1. 문자열인 경우: JSON 로드
        try:
            sa_info = json.loads(service_account_data.strip())
        except json.JSONDecodeError as e:
            return None, f"[Error] JSON 구문 오류: {e}"
    elif hasattr(service_account_data, 'get'):
        # 2. AttrDict (secrets.toml 딕셔너리 형식)인 경우: dict로 변환
        try:
            sa_info = dict(service_account_data) # AttrDict를 표준 dict로 변환
        except Exception:
             return None, f"[Error] 딕셔너리 변환 실패. 타입: {type(service_account_data)}"
    
    # ... (생략: project_id, private_key 존재 여부 확인)
    return sa_info, None</pre>
                    </div>
                </div>
                
                <!-- Step 3: Admin SDK Initialization Fix -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-red-500">
                    <h3 class="text-xl font-bold text-red-700 mb-3">단계 3: Invalid Private Key 및 Admin SDK 인증 (Key Validation)</h3>
                    <p class="text-gray-600 mb-3">모든 구문 오류를 해결했음에도 발생한 "Invalid private key" 오류는, Secrets에 저장된 키의 포맷이 Admin SDK가 요구하는 Raw String 포맷과 정확히 일치하지 않았기 때문이었습니다. Secrets를 단일 라인 문자열 형식으로 정리하여 문제를 최종 해결했습니다.</p>
                    <p class="text-gray-500 text-sm italic">Resolved the "Invalid private key" error by rigorously ensuring the private key within the Secrets file matched the exact Raw String format expected by the Admin SDK, finally achieving successful authentication.</p>
                </div>

                <!-- Step 4: Firestore Rules Fix -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-green-500">
                    <h3 class="text-xl font-bold text-green-700 mb-3">단계 4: Firestore 규칙 및 쓰기 권한 확보 (Rules and Write Access)</h3>
                    <p class="text-gray-600 mb-3">앱의 데이터베이스 저장 기능이 작동하도록, `rag_indices` 컬렉션에 대한 `read, write` 규칙을 명시적으로 부여하여 최종적으로 RAG 인덱스 영구 저장 기능을 활성화했습니다.</p>
                    <p class="text-gray-500 text-sm italic">Granted explicit `read, write` rules to the `rag_indices` collection in Firebase Firestore to finalize the persistence layer functionality.</p>
                </div>
            </div>
        </section>
        
        <!-- Section 3: Final Outcome Chart -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">3. 최종 문제 해결 노력 분석 (Effort Analysis)</h2>
            <div class="bg-white p-6 rounded-xl shadow-md">
                <canvas id="timeChart"></canvas>
                <p class="text-sm text-gray-500 text-center mt-4">복잡한 통합 문제 해결에 소요된 노력 비율 (가정)</p>
            </div>
        </section>

        <!-- Footer -->
        <footer class="text-center text-gray-500 mt-12 pt-4 border-t border-gray-300">
            <p>&copy; 2025 AI Coach Portfolio. Streamlit 및 Gemini API를 기반으로 개발되었습니다.</p>
        </footer>

    </div>

    <script>
        const ctx = document.getElementById('timeChart');

        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: ['DB Mode/Project Change', 'Secrets JSON Parsing', 'Private Key Authentication', 'Firestore Rules/Permissions'],
                datasets: [{
                    label: '해결 노력 비율 (Effort Ratio)',
                    data: [25, 35, 30, 10], // 비율 (합계 100)
                    backgroundColor: [
                        'rgba(233, 30, 99, 0.7)',  // Pink/Fuchsia
                        'rgba(255, 193, 7, 0.7)',  // Amber/Yellow
                        'rgba(244, 67, 54, 0.7)',  // Red
                        'rgba(76, 175, 80, 0.7)'   // Green
                    ],
                    borderColor: [
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: false
                    }
                }
            }
        });
    </script>
</body>
</html>
