<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Coach Portfolio - Technical Challenge Resolution Story</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Noto+Sans+KR:wght@100..900&display=swap');
        body { 
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: #f7f9fb; /* Light background for clean look */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 sm:p-8 max-w-4xl">

        <!-- Header -->
        <header class="text-center mb-12 py-8 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-700">AI Study Coach Portfolio</h1>
            <p class="mt-2 text-xl text-gray-500">Technical Challenge: Persistence Layer Implementation Success Story</p>
        </header>

        <!-- Section 1: Challenge Overview -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">1. Challenge Overview</h2>
            <div class="bg-white p-6 rounded-xl shadow-md">
                <p class="text-lg mb-4 text-gray-600">During the process of integrating Google Cloud Firestore (GCP) to persistently store RAG indices (FAISS) within the Streamlit Cloud serverless environment, we faced unexpected server authentication conflicts and configuration issues.</p>
                
                <h3 class="text-2xl font-semibold text-gray-600 mt-6 mb-4">Core Problem: Admin SDK Initialization Failures</h3>
                <div class="bg-red-50 p-4 rounded-lg border border-red-300">
                    <p class="text-red-700 font-medium">Key Errors Experienced: Complex issues including JSON syntax errors, Datastore Mode conflicts, Invalid private key errors, and AttrDict type mismatches.</p>
                </div>
            </div>
        </section>

        <!-- Section 2: Step-by-Step Resolution (Visualized) -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">2. Step-by-Step Resolution</h2>
            
            <div id="resolution-steps" class="space-y-8">
                
                <!-- Step 1: Mode Conflict & Project Change -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-fuchsia-500">
                    <h3 class="text-xl font-bold text-fuchsia-700 mb-3">Step 1: DB Mode Conflict and Project Change</h3>
                    <p class="text-gray-600 mb-3">We identified a 400 error caused by the project being set to Datastore Mode when Firestore Native Mode was required. We created a new Firebase project in Native Mode and replaced the Service Account key.</p>
                </div>

                <!-- Step 2: JSON Parsing/Escape Fix (UPDATED WITH CODE) -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-yellow-500">
                    <h3 class="text-xl font-bold text-yellow-700 mb-3">Step 2: Secrets JSON Parsing and Validation</h3>
                    <p class="text-gray-600 mb-3">To resolve JSON syntax errors (unicode control characters, escape characters) and the Streamlit AttrDict type issue, we implemented logic that explicitly forces the conversion of the secrets key into a standard Python dictionary (dict), ensuring compatibility with the Firebase Admin SDK.</p>
                    
                    <p class="mt-4 font-semibold text-gray-700">Applied Python Code (_get_admin_credentials function)</p>
                    <div class="bg-gray-800 text-green-300 p-4 rounded-lg text-xs overflow-x-auto mt-2 shadow-inner">
<pre class="whitespace-pre-wrap">def _get_admin_credentials():
    # ... (Skipped: Secret existence check)
    
    service_account_data = st.secrets["FIREBASE_SERVICE_ACCOUNT_JSON"]
    sa_info = None

    if isinstance(service_account_data, str):
        # 1. If string: Load JSON
        try:
            sa_info = json.loads(service_account_data.strip())
        except json.JSONDecodeError as e:
            return None, f"[Error] JSON Syntax Error: {e}"
    elif hasattr(service_account_data, 'get'):
        # 2. If AttrDict (secrets.toml dictionary format): Convert to dict
        # Handles AttrDict type returned from Streamlit Secrets
        try:
            sa_info = dict(service_account_data) # Convert AttrDict to standard dict
        except Exception:
             return None, f"[Error] Dictionary conversion failed. Type: {type(service_account_data)}"
    
    # ... (Skipped: project_id, private_key existence check)
    return sa_info, None</pre>
                    </div>
                </div>
                
                <!-- Step 3: Admin SDK Initialization Fix -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-red-500">
                    <h3 class="text-xl font-bold text-red-700 mb-3">Step 3: Invalid Private Key and Admin SDK Authentication</h3>
                    <p class="text-gray-600 mb-3">The "Invalid private key" error, which occurred even after fixing all syntax errors, was due to the key format in Secrets not matching the exact Raw String format required by the Admin SDK. We ultimately fixed this by standardizing the Secrets to a single-line string format.</p>
                </div>

                <!-- Step 4: Firestore Rules Fix -->
                <div class="bg-white p-6 rounded-xl shadow-md border-l-4 border-green-500">
                    <h3 class="text-xl font-bold text-green-700 mb-3">Step 4: Firestore Rules and Write Access</h3>
                    <p class="text-gray-600 mb-3">To enable the app's database saving functionality, we explicitly granted `read, write` rules to the `rag_indices` collection in Firebase Firestore, finally activating the RAG index persistence feature.</p>
                </div>
            </div>
        </section>
        
        <!-- Section 3: Final Outcome Chart -->
        <section class="mb-12">
            <h2 class="text-3xl font-bold text-gray-700 mb-6 border-b-2 border-indigo-400 pb-2">3. Effort Analysis</h2>
            <div class="bg-white p-6 rounded-xl shadow-md">
                <canvas id="timeChart"></canvas>
                <p class="text-sm text-gray-500 text-center mt-4">Estimated effort distribution for resolving complex integration issues.</p>
            </div>
        </section>

        <!-- Footer -->
        <footer class="text-center text-gray-500 mt-12 pt-4 border-t border-gray-300">
            <p>&copy; 2025 AI Coach Portfolio. Developed with Streamlit and Gemini API.</p>
        </footer>

    </div>

    <script>
        const ctx = document.getElementById('timeChart');

        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: ['DB Mode / Project Change', 'Secrets JSON Parsing', 'Private Key Authentication', 'Firestore Rules / Permissions'],
                datasets: [{
                    label: 'Effort Ratio',
                    data: [25, 35, 30, 10], // Total 100
                    backgroundColor: [
                        'rgba(233, 30, 99, 0.7)',  // Pink/Fuchsia
                        'rgba(255, 193, 7, 0.7)',  // Amber/Yellow
                        'rgba(244, 67, 54, 0.7)',  // Red
                        'rgba(76, 175, 80, 0.7)'   // Green
                    ],
                    borderColor: [
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)',
                        'rgba(255, 255, 255, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: false
                    }
                }
            }
        });
    </script>
</body>
</html>
